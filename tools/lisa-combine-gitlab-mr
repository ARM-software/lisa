#! /usr/bin/env python3
#
# SPDX-License-Identifier: Apache-2.0
#
# Copyright (C) 2024, Arm Limited and contributors.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import subprocess
from itertools import chain
from tempfile import NamedTemporaryFile
import json, os
from collections import ChainMap
from operator import itemgetter
import argparse
import logging
import requests

# Use HTTP APIs of GitLab to retrieve associated mrs
# of this project.
def get_gitlab_mrs(state="opened", scope="all", labels=""):
    def _call_gitlab_api(endpoint):
        api_token = os.environ.get("GITLAB_REPO_TOKEN")
        api_url = os.environ.get("CI_API_V4_URL")
        headers = {"PRIVATE-TOKEN": api_token}
        r = requests.get("/".join([api_url,endpoint]), headers=headers)
        if r.status_code != 200:
            raise Exception(r.text)
        return r

    this_project_id = int(os.environ.get("CI_PROJECT_ID"))
    page_number = 1  # obvioulsy at start 1

    results = []
    while True:
        mr_response = _call_gitlab_api(
            f"merge_requests?state={state}&scope={scope}&labels={labels}&page={page_number}"
        )
        for this_mr in mr_response.json():
            if this_mr.get("project_id") == this_project_id:
                # populate commits count - use another api
                mr_commit_response = _call_gitlab_api(
                    f"projects/{this_project_id}/merge_requests/{this_mr['iid']}/commits"
                )
                this_mr["commits_count"] = len(mr_commit_response.json())

                # this_mr could be from a fork - use another api
                project_response = _call_gitlab_api(
                    f"projects/{this_mr['source_project_id']}"
                )
                this_mr["http_url_to_repo"] = project_response.json()[
                    "http_url_to_repo"
                ]

                results.append(this_mr)

        # handle paging - only required for mr
        if not mr_response.headers["X-Next-Page"]:
            break
        page_number = mr_response.headers["X-Next-Page"]

    return results

def main():
    parser = argparse.ArgumentParser(
        description="""
        Combine gitlab merge requests with the given tag into a branch, rebasing all
        MRs on top of each other.
        """,
    )

    parser.add_argument('--repo', required=True, help='Gitlab repository as owner/name')
    parser.add_argument('--mr-label', action='append', required=True, help='Merge request labels to look for')
    parser.add_argument('--branch', required=True, help='Name of the branch to be created. If the branch exists, it will be forcefully updated')

    args = parser.parse_args()

    project = args.repo
    owner, repo = args.repo.split('/', 1)
    labels = ','.join(args.mr_label)
    branch = args.branch

    logging.basicConfig(level=logging.INFO)

    server_host_ssh = os.environ.get('CI_SERVER_SHELL_SSH_HOST')

    gl_mrs = get_gitlab_mrs(labels=labels)

    def make_topic(mr):
        remote = f'remote_{mr["sha"]}'
        return (
            {
                remote: {
                    'url': mr["http_url_to_repo"]
                }
            },
            {
                'name': mr["source_branch"],
                'remote': remote,
                'nr-commits': mr["commits_count"],
                'tip': mr["source_branch"],
            }
        )
    
    topics = []
    
    for mr in gl_mrs:
        topics += [ make_topic(mr) ]

    remotes, topics = zip(*topics) if topics else ([], [])
    remotes = dict(ChainMap(*chain(
        [{
            'gitlab': {
            'url': f'https://{server_host_ssh}/{owner}/{repo}.git'
            }
        }],
        remotes
    )))

    conf = {
        'rebase-conf': {
            'rr-cache': './rr-cache',
            'remotes': remotes,
            'base': {
                'remote': 'gitlab',
                'ref': 'main',
            },
            'topics': sorted(topics, key=itemgetter('name'))
        }
    }
    conf = json.dumps(conf, indent=4)
    logging.info(conf)

    with NamedTemporaryFile(mode='w+', suffix='.manifest.json') as f:
        f.write(conf)
        f.flush()

        manifest = f.name

        cmd = ['batch-rebase', 'create', '.', '--manifest', manifest, '--create-branch', branch]
        logging.info(f'Running {" ".join(map(str, cmd))}')
        subprocess.check_call(cmd)

main()
